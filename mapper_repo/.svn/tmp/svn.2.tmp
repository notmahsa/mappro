/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
#include "m3.h"
#include "m2.h"
#include "m1.h"
#include "graphics.h"
#include "StreetsDatabaseAPI.h"
#include "OSMDatabaseAPI.h"
#include "MapParser.h"
#include <X11/keysym.h>
#include <graphics.cpp>
#include <deque>
#include "Surface.h"
#include <math.h>
#include <boost/algorithm/string.hpp>
#include <string>

#define MAX 9999999999999
/*******************************************/
/*             FEATURE VARIABLES           */
/*******************************************/
const t_bound_box initial_coords = t_bound_box(0, 0, 1000, 1000);
//t_point minScrn,maxScrn;
double lat_avg;
float xmin, xmax, ymin, ymax;

/*******************************************/
/*             FEATURE VECTORS             */
/*******************************************/
extern std::vector<unsigned> buildings;

extern std::deque<featureInfo> features_by_area;
extern std::vector<featureInfo> zero_area_features;
extern std::vector<featureInfo> open_features;

mapData mapInfo;
std::vector<double> coords;

/*******************************************/
/*           HIGHLIGHT VECTORS             */
/*******************************************/
std::vector<unsigned> found_intersections;
bool highlightIntersections;


std::unordered_map<string, string> tags;

/*void act_on_key_press(char c, int keysym) {
    // function to handle keyboard press event, the ASCII character is returned
    // along with an extended code (keysym) on X11 to represent non-ASCII
    // characters like the arrow keys.

    update_message("Finding: "+c);
}*/

/*******************************************/
/*            VOID FUNCTION                */

/*******************************************/

void find(void (*drawscreen) (void)) {
    highlightIntersections = true;
    found_intersections.clear();
    string findStr, street1, street2;
    update_message("Input intersection in terminal with format: street1 and street2");
    std::cout << "Input intersection in terminal with format: street1 and street2" << std::endl;
    getline(cin, findStr);

    stringstream findStrStm(findStr);
    findStrStm>>street1;

    string next;
    findStrStm>>next;
    while (next != "and") {
        street1 = street1 + " " + next;
        findStrStm>>next;
    }

    findStrStm>>street2;
    while (!findStrStm.eof()) {
        findStrStm>>next;
        street2 = street2 + " " + next;
    }

    string upSt1 = boost::to_upper_copy<std::string>(street1);
    string upSt2 = boost::to_upper_copy<std::string>(street2);

    std::unordered_map<std::string, std::vector<unsigned>>::iterator streetIt;

    string st1Actual, st2Actual;

    bool oneFound = false, twoFound = false;
    std::vector<string> street1Auto, street2Auto;

    for (streetIt = mapInfo.NameToStreetID.begin(); streetIt != mapInfo.NameToStreetID.end(); ++streetIt) {
        std::string itKey = boost::to_upper_copy<std::string>(streetIt->first);

        if (upSt1 == itKey) {
            oneFound = true;
            st1Actual = streetIt->first;
        } else if (upSt2 == itKey) {
            twoFound = true;
            st2Actual = streetIt->first;
        } else if (oneFound && twoFound) {
            break;
        } else if (!oneFound && upSt1 == (itKey).substr(0, upSt1.length())) {
            street1Auto.push_back(streetIt->first);
        } else if (!twoFound && upSt2 == (itKey).substr(0, upSt2.length())) {
            street2Auto.push_back(streetIt->first);
        }
    }

    if (oneFound && twoFound)
        update_message("Finding intersection: " + st1Actual + " & " + st2Actual);

    else if (oneFound) {
        update_message("Street2 not found");
        cout << "\nOptions for street 2\n";
        for (int i = 0; i < street2Auto.size(); i++) {
            cout << street2Auto[i] << std::endl;
        }
        return;
    } else if (twoFound) {
        update_message("Street1 not found");
        cout << "\nOptions for street 1\n";
        for (int i = 0; i < street1Auto.size(); i++) {
            cout << street1Auto[i] << std::endl;
        }
        return;
    } else {
        update_message("Both streets not found");

        cout << "\nOptions for street 1\n";
        for (int i = 0; i < street1Auto.size(); i++) {
            cout << street1Auto[i] << std::endl;
        }

        cout << "\nOptions for street 2\n";
        for (int i = 0; i < street2Auto.size(); i++) {
            cout << street2Auto[i] << std::endl;
        }

        return;
    }

    found_intersections = find_intersection_ids_from_street_names(st1Actual, st2Actual);

    for (int i = 0; i < found_intersections.size(); i++) {
        cout << getIntersectionName(found_intersections[i]) << std::endl;
        cout << mapInfo.intersection_position[found_intersections[i]].lat() << std::endl;
        cout << mapInfo.intersection_position[found_intersections[i]].lon() << std::endl << std::endl;
    }
    if (found_intersections.size() > 0) {
        t_point pos = getXY(mapInfo.intersection_position[found_intersections[0]]);
        zoom_fit(drawscreen);
        while (zoom_level < 6) {
            handle_zoom_in(pos.x, pos.y, drawscreen);
        }
    }

}

/*******************************************/
/*             DRAW MAP                    */

/*******************************************/

void draw_map() {
    coords = calcInitialCoordinates(true);


    init_graphics("Map of the City", MAPGREY);

    create_button("Window", "Find", find);
    create_button("Find", "Load map", act_on_load_new_map);
    create_button("Load map", "POI Names", show_poi_names);
    create_button("POI Names", "More POIs", more_poi_display);

    set_drawing_buffer(OFF_SCREEN);
    set_visible_world(coords[0], coords[1], coords[2], coords[3]);

    event_loop(act_on_mousebutton, NULL, NULL, drawscreen);
    //event_loop(NULL, NULL, NULL, drawscreen);
    //event_loop(act_on_button_press, act_on_mouse_move, act_on_key_press, drawscreen);
    drawscreen();

}


/*******************************************/
/*               DRAW SCREEN               */

/*******************************************/
void drawscreen(void) {

    /* The redrawing routine for still pictures.  The graphics package calls  
     * this routine to do redrawing after the user changes the window 
     * in any way.                                                    
     */

    set_drawing_buffer(OFF_SCREEN);
    set_draw_mode(DRAW_NORMAL); // Should set this if your program does any XOR drawing in callbacks.
    clearscreen(); /* Should precede drawing for all drawscreens */



    setfontsize(10);
    setlinestyle(SOLID);
    setlinewidth(0);
    setcolor(WHITE);
    {

        // call the zoom helper function based on what the zoom level is
        switch (zoom_level) {
            case 0:
                zoom0_draw();
                break;
            case 1:
                zoom1_draw();
                break;
            case 2:
                zoom2_draw();
                break;
            case 3:
                zoom3_draw();
                break;
            case 4:
                zoom4_draw();
                break;
            case 5:
                zoom5_draw();
                break;
            case 6:
                zoom6_draw();
                break;
            case 7:
                zoom7_draw();
                break;
            case 8:
                zoom8_draw();
                break;
            case 9:
                zoom9_draw();
                break;
            case 10:
                zoom10_draw();
                break;
            default:
                std::cout << "zoom error" << std::endl;
                break;
        }
        clear_popup();
        update_message_popup("Information Panel");
        update_message_popup("");

        if (highlightIntersections) {

            // highlight the intersection that the find function locates
            std::string lat, lon, found;
            for (unsigned i = 0; i < found_intersections.size(); i++) {

                // update the information panel with the found intersections
                lat = std::to_string(mapInfo.intersection_position[found_intersections[i]].lat()) + " latitude";
                lon = std::to_string(mapInfo.intersection_position[found_intersections[i]].lon()) + " longitude";
                found = "Intersection " + std::to_string(i + 1);
                update_message_popup(found);
                update_message_popup(lat);
                update_message_popup(lon);
                highlight_intersection(found_intersections[i]);
            }
            if (found_intersections.size() == 0) {
                update_message_popup("Intersection not found");
            }
        }


    }

    // Need to copy the off screen buffer to screen if we're using double buffering.
    // Harmless to call this if we're not using double-buffering.
    copy_off_screen_buffer_to_screen();
}

/*******************************************/
/*     CALCULATE INITAL COORDINATES        */

/*******************************************/

std::vector<double> calcInitialCoordinates(bool xy) {
    // holds initial coordinates to display the map
    std::vector<double> map_coords;
    double minLon, minLat, maxLon, maxLat;

    LatLon point, point2, compare;
    // find the first and last intersection coordinates
    point = mapInfo.intersection_position[0];
    point2 = mapInfo.intersection_position[mapInfo.interNum - 1];

    // set the first and last lat/lons as the initial min/max
    minLon = point.lon();
    minLat = point.lat();
    maxLon = point2.lon();
    maxLat = point2.lat();

    // check all intersections, to find max and min of the map
    for (unsigned i = 0; i < mapInfo.interNum; i++) {
        compare = mapInfo.intersection_position[i];
        if (compare.lon() < minLon) {
            minLon = compare.lon();
        } else if (compare.lon() > maxLon) {
            maxLon = compare.lon();
        }

        if (compare.lat() < minLat) {
            minLat = compare.lat();
        } else if (compare.lat() > maxLat) {
            maxLat = compare.lat();
        }
    }
    // store the global value of lat_avg to use when converting to XY
    lat_avg = (minLat + maxLat) / 2;

    // converts lat/lon to XY
    if (xy) {
        minLon = minLon * DEG_TO_RAD * cos(lat_avg * DEG_TO_RAD);
        maxLon = maxLon * DEG_TO_RAD * cos(lat_avg * DEG_TO_RAD);

        minLat = minLat * DEG_TO_RAD;
        maxLat = maxLat * DEG_TO_RAD;
    }

    // stores max/min in a vector in the order they are
    // used to plot the initial map
    map_coords.push_back(minLon);
    map_coords.push_back(minLat);
    map_coords.push_back(maxLon);
    map_coords.push_back(maxLat);
    return map_coords;
}

/*******************************************/
/*             GET X,Y COOR                */

/*******************************************/
t_point getXY(LatLon point) {
    float x1, y1;

    x1 = point.lon() * DEG_TO_RAD * cos(lat_avg * DEG_TO_RAD);

    y1 = point.lat() * DEG_TO_RAD;

    return t_point(x1, y1);
}

/*******************************************/
/*          GET LAT LON COOR               */

/*******************************************/
LatLon getLatLon(float x, float y) {
    float lat, lon;

    lon = x / (DEG_TO_RAD * cos(lat_avg * DEG_TO_RAD));
    lat = y / DEG_TO_RAD;

    return LatLon(lat, lon);
}

/*******************************************/
/*           DRAW STREET SEGMENTS          */

/*******************************************/
void draw_street_segment(unsigned segmentIndex, t_color color, int width) {

    setlinewidth(width);
    setcolor(color);

    t_point p1, p2;
    std::vector<LatLon> points;
    points.push_back(mapInfo.intersection_position[mapInfo.street_segment_info[segmentIndex].from]);

    double length = 0;
    LatLon curvePoint;

    // add the lat/lon of any curve points in the segment to the back of the vector
    if (mapInfo.street_segment_info[segmentIndex].curvePointCount != 0) {
        for (unsigned i = 0; i < mapInfo.street_segment_info[segmentIndex].curvePointCount; i++) {
            curvePoint = getStreetSegmentCurvePoint(segmentIndex, i);
            points.push_back(curvePoint);
        }
    }
    // add the ending intersection to the vector
    points.push_back(mapInfo.intersection_position[mapInfo.street_segment_info[segmentIndex].to]);

    // sum the distance between each intersection/curve point
    for (unsigned i = 0; i < points.size() - 1; i++) {
        p1 = getXY(points[i]);
        p2 = getXY(points[i + 1]);

        drawline(p1, p2);
    }
}

/*******************************************/
/*              DRAW ARROW                 */

/*******************************************/
void draw_arrow(float x1, float y1, float x2, float y2, bool twoway) {
    drawline(x1, y1, x2, y2);

    double angle = atan2((y1 - y2), (x1 - x2));

    float l = 0.00005, angcos, angsin;
    angcos = l * cos(angle);
    angsin = l * sin(angle);

    drawline(x2, y2, x2 + angcos - angsin / 2, y2 + angsin + angcos / 2);
    drawline(x2, y2, x2 + angcos + angsin / 2, y2 - angcos / 2 + angsin);

    if (twoway) {
        drawline(x1, y1, x1 - angcos - angsin / 2, y1 - angsin + angcos / 2);
        drawline(x1, y1, x1 - angcos + angsin / 2, y1 + angcos / 2 - angsin);
    }
}

// this function checks to see whether or not the feature has the same 
// starting point and ending point. If they are the same, the feature
// is considered a closed feature and the function returns true

bool is_closed(unsigned featureIndex) {
    // assume that the start and end points of a feature are different
    bool closed = false;

    // get the number of points in the feature
    unsigned count = getFeaturePointCount(featureIndex);

    // create t points of the first and last feature points
    t_point A = getXY(getFeaturePoint(featureIndex, 0));
    t_point B = getXY(getFeaturePoint(featureIndex, count - 1));

    // compare the x and y values of the start and end point
    // if they match return true
    if (A.x == B.x) {
        if (A.y == B.y) {
            closed = true;
        }
    }

    return closed;
}

/*******************************************/
/*             DRAW FEATURES               */
/*******************************************/

// this function takes in the index of the feature, and the color that 
// the feature should be drawn with. It then checks to see if the
// feature should be drawn as a closed polygon, or a multi segmented line
// then it draws it to the screen

void draw_features(unsigned featureIndex, t_color colour, bool closed) {
    // get the number of points in the feature and set the colour of the line/polygon
    unsigned count = getFeaturePointCount(featureIndex);
    setcolor(colour);

    // check if it is a closed or open feature
    if (closed) {

        // create an array of t_points to store the vertices of the polygon
        t_point polypts[count];

        // add the vertices to the array
        for (unsigned i = 0; i < count; i++) {
            polypts[i] = getXY(getFeaturePoint(featureIndex, i));
        }

        // draw the polygon
        fillpoly(polypts, count);
    } else {
        // create two points to draw a line between
        t_point p1, p2;

        // draw lines between each set of two points in the feature
        for (unsigned i = 0; i < count - 1; i++) {
            p1 = getXY(getFeaturePoint(featureIndex, i));
            p2 = getXY(getFeaturePoint(featureIndex, i + 1));
            drawline(p1, p2);
        }
    }
}

/*******************************************/
/*             DRAW ICONS                  */
/*******************************************/

// this function takes the path to the png file, and the lat lon position
// that it should be drawn at and converts it to xy coordinates, and draws it

void draw_icons(const char* path, LatLon point) {
    t_point t = getXY(point);
    draw_surface(load_png_from_file(path), t.x, t.y);
}

/*******************************************/
/*           POLYGON AREA                  */

/*******************************************/
double poly_area(std::vector<t_point> points) {
    double area = 0;
    unsigned size = points.size();

    // calculate the determinant -> aka the area of the polygon
    for (unsigned i = 0; i < size - 1; i++) {
        area += (points[i].x * points[i + 1].y);
        area -= (points[i + 1].x * points[i].y);
    }
    area += (points[size - 1].x * points[0].y);
    area -= (points[0].x * points[size - 1].y);

    // take the absolute value and divide it by 2
    area = std::abs(area) / 2;

    return area;
}

/*******************************************/
/*           DRAW STREET NAMES             */

/*******************************************/

void draw_street_name(unsigned segment_id, unsigned zoom_level) {
    t_point begin = getXY(getIntersectionPosition(mapInfo.street_segment_info[segment_id].from));
    t_point end = getXY(getIntersectionPosition(mapInfo.street_segment_info[segment_id].to));

    unsigned stID = mapInfo.street_segment_info[segment_id].streetID;
    if (mapInfo.street_segment_info[segment_id].oneWay && begin.x < end.x)
        return;
    std::string name = getStreetName(stID);
    vector<unsigned> allIDs = find_street_ids_from_name(name);
    if (stID != allIDs[0])
        return;

    if (name == "<unknown>")
        return;

    t_point center;

    //unsigned curvePoints = getStreetSegmentCurvePoint(segment_id);
    unsigned curveNum = mapInfo.street_segment_info[segment_id].curvePointCount;
    if (curveNum < 2) {
        center.x = (begin.x + end.x) / 2;
        center.y = (begin.y + end.y) / 2;
    } else {
        LatLon curvePoint = getStreetSegmentCurvePoint(segment_id, curveNum / 2);
        //std::cout << curvePoint.lat() << std::endl;
        center.x = (begin.x + end.x) / 2;
        center.y = (begin.y + end.y) / 2;
    }



    double length = find_street_segment_length(segment_id);
    unsigned min = 6700 / (zoom_level * zoom_level);

    if (length < min) {
        return;
    }

    double angle = find_text_angle(begin, end);

    double boundx, boundy;
    boundx = length * cos(angle);
    boundy = length * sin(angle);

    unsigned fSize = 10 - zoom_level / 3 - name.length() / 15;
    settextrotation(angle);
    if (zoom_level > 7) {
        setcolor(t_color(255, 255, 255));
        setfontsize(fSize);
        drawtext(center, name, length / 1000000, length / 1000000);
        setcolor(t_color(10, 10, 10));
        setfontsize(fSize);
        drawtext(center, name, length / 1000000, length / 1000000);
    } else {
        setcolor(t_color(255, 255, 255));
        setfontsize(fSize);
        drawtext(center, name, (boundx / 600000) / 2, (boundy / 600000) / 2);
        setcolor(t_color(10, 10, 10));
        setfontsize(fSize);
        drawtext(center, name, (boundx / 600000) / 2, (boundy / 600000) / 2);
    }
}

/*******************************************/
/*           FIND TEXT ANGLES              */

/*******************************************/
double find_text_angle(t_point begin, t_point end) {
    double angle = 0;
    if (begin.y == end.y) {
        return 0;
    } else if (begin.x == end.x) {
        return 90;
    }

    // convert to degrees
    angle = atan((end.y - begin.y) / (end.x - begin.x))*180 / PI;

    return angle;
}

/*******************************************/
/*          ACT ON LOAD NEW MAP            */
/*******************************************/

// this function is called when the "Load map" button is pressed within the menu bar
// it asks the user whether they want to use a custom map path or an ece297 path
// it gets rid of the osm or streets ending if there is one
// and closes the current map and loads a new one

void act_on_load_new_map(void (*drawscreen_ptr) (void)) {
    highlightIntersections = false;
    std::string mapPath, s, o, standard, city;
    s = ".streets.bin";
    o = ".osm.bin";
    zoom_level = 0;

    // update the message bar at the bottom of the map
    update_message("Please enter a new map path in the console");

    // ask the user what type of path they want to use
    std::cout << "Do you want to use a standard ece297 map? (y/n)  ";
    std::cin >> standard;

    // check all plausible user responses
    if (standard == "y" || standard == "Y" || standard == "yes" || standard == "Yes") {
        standard = "y";

        // give the user the beginning of the path
        std::cout << "\n/cad2/ece297s/public/maps/";
    } else {

        // ask for the custom path
        std::cout << "Enter custom map path: \n";
    }

    // take in the path from the user
    std::cin >> city;

    // look for the suffix .osm and .street
    std::string::size_type streetData = city.find(s);
    std::string::size_type osmData = city.find(o);

    // if either ending is found, remove it, since load map accounts for these endings
    if (streetData != std::string::npos) {
        city.erase(streetData, s.length());
    }
    if (osmData != std::string::npos) {
        city.erase(streetData, o.length());
    }

    // set the map path
    if (standard == "y") {
        mapPath = "/cad2/ece297s/public/maps/" + city;
    } else {
        mapPath = city;
    }

    bool loaded = false;

    // close the current map
    close_map();

    // load a new map and set the value of loaded
    loaded = load_map(mapPath);

    // if the new map was successfully loaded, fill in the necessary info
    if (loaded) {

        // find new display coordinates
        coords = calcInitialCoordinates(true);
        set_visible_world(coords[0], coords[1], coords[2], coords[3]);

        // draw the new map
        drawscreen();

        // update the map message bar to say which map was loaded
        update_message(city + " was loaded");
    }

}

/*******************************************/
/*        DRAW SEGMENT DIRECTION           */

/*******************************************/

void draw_segment_direction(unsigned index) {
    //if (mapInfo.street_segment_info[index].curvePointCount > 4) return;
    t_point from = getXY(getIntersectionPosition(mapInfo.street_segment_info[index].from));
    t_point to = getXY(getIntersectionPosition(mapInfo.street_segment_info[index].to));
    bool oneway = mapInfo.street_segment_info[index].oneWay;

    string arrow;
    if (oneway)
        arrow = "↑";
    else
        arrow = "↕";
    double length = find_street_segment_length(index);
    if (length < 150) return;

    t_point center;
    center.x = (from.x + to.x) / 2;
    center.y = (from.y + to.y) / 2;

    double angle = find_text_angle(from, to) + 90;
    setcolor(t_color(100, 100, 100));
    setfontsize(9);

    settextrotation(angle);
    drawtext(center, arrow, length * cos(angle) / 1000, length * sin(angle) / 1000);

}

/*******************************************/
/*              ZOOM0 DRAW                 */

/*******************************************/
void zoom0_draw() {

    // draw the features in the order of decreasing area
    for (unsigned i = 0; i < (mapInfo.features_by_area.size()); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }

    // draw major roads
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_segment(mapInfo.major_roads[j], WHITE, 3);

    }

    // draw highways on top
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_segment(mapInfo.highways[j], ORANGE, 4);
    }

}

/*******************************************/
/*             ZOOM1 DRAW                  */

/*******************************************/
void zoom1_draw() {
    zoom0_draw();
    draw_poi(mapInfo.features_by_area.size() / 10);
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 1);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 3);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.highways[j]);
    }

}

/*******************************************/
/*             ZOOM2 DRAW                  */

/*******************************************/
void zoom2_draw() {
    // draw the features from the outermost zoom level
    zoom0_draw();
    draw_poi(mapInfo.features_by_area.size() / 50);
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 2);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 3);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.highways[j]);
    }

}

/*******************************************/
/*               ZOOM3 DRAW                */

/*******************************************/
void zoom3_draw() {

    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 4);
    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 5);
    draw_poi(mapInfo.features_by_area.size() / 100);
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 3);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 3);
        //if (j%2 == 0)
        //    draw_segment_direction(mapInfo.highways[j]);
    }

}

/*******************************************/
/*            ZOOM4 DRAW                   */

/*******************************************/
void zoom4_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 4);
    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 5);
    draw_poi(mapInfo.features_by_area.size() / 200);
    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 4);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 3);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }



}

/*******************************************/
/*                ZOOM5 DRAW               */

/*******************************************/

void zoom5_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }

    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_segment(mapInfo.major_roads[j], WHITE, 6);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_segment(mapInfo.highways[j], ORANGE, 7);

    }


    for (unsigned i = 0; i < mapInfo.minor_roads.size(); i++) {
        draw_street_segment(mapInfo.minor_roads[i], WHITE, 3);
    }
    for (unsigned i = 0; i < mapInfo.buildings.size(); i++) {
        bool closed = is_closed(i);
        draw_features(mapInfo.buildings[i], t_color(222, 198, 182), closed);
    }
    draw_poi(mapInfo.features_by_area.size() / 400);
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 5);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }

    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 4);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }

    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
}


/*******************************************/
/*                ZOOM6 DRAW               */

/*******************************************/
void zoom6_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 6);
    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 7);



    for (unsigned i = 0; i < mapInfo.minor_roads.size(); i++) {
        draw_street_segment(mapInfo.minor_roads[i], WHITE, 5);
    }
    for (unsigned i = 0; i < mapInfo.buildings.size(); i++) {
        bool closed = is_closed(i);
        draw_features(mapInfo.buildings[i], t_color(222, 198, 182), closed);
    }
    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
    draw_poi(5);
    for (unsigned i = 0; i < mapInfo.zero_area_features.size(); i++) {
        draw_features(mapInfo.zero_area_features[i].index, mapInfo.zero_area_features[i].colour, mapInfo.zero_area_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 6);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 5);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }

}

/*******************************************/
/*                ZOOM7 DRAW               */

/*******************************************/
void zoom7_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 6);
    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 7);



    for (unsigned i = 0; i < mapInfo.minor_roads.size(); i++) {
        draw_street_segment(mapInfo.minor_roads[i], WHITE, 5);
    }
    for (unsigned i = 0; i < mapInfo.buildings.size(); i++) {
        bool closed = is_closed(i);
        draw_features(mapInfo.buildings[i], t_color(222, 198, 182), closed);
    }
    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
    draw_poi(2);
    for (unsigned i = 0; i < mapInfo.zero_area_features.size(); i++) {
        draw_features(mapInfo.zero_area_features[i].index, mapInfo.zero_area_features[i].colour, mapInfo.zero_area_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 7);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 6);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }
    for (unsigned j = 0; j < mapInfo.minor_roads.size(); j++) {
        //draw_street_name(mapInfo.minor_roads[j], 7);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.minor_roads[j]);
    }
}

/*******************************************/
/*                ZOOM8 DRAW               */

/*******************************************/
void zoom8_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 10);

    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 10);

    for (unsigned i = 0; i < mapInfo.minor_roads.size(); i++) {
        draw_street_segment(mapInfo.minor_roads[i], WHITE, 7);
    }
    for (unsigned i = 0; i < mapInfo.buildings.size(); i++) {
        bool closed = is_closed(i);
        draw_features(mapInfo.buildings[i], t_color(222, 198, 182), closed);
    }
    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
    draw_poi(1);
    for (unsigned i = 0; i < mapInfo.zero_area_features.size(); i++) {
        draw_features(mapInfo.zero_area_features[i].index, mapInfo.zero_area_features[i].colour, mapInfo.zero_area_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 8);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 7);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }
    for (unsigned j = 0; j < mapInfo.minor_roads.size(); j++) {
        draw_street_name(mapInfo.minor_roads[j], 8);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.minor_roads[j]);
    }
}

/*******************************************/
/*                ZOOM9 DRAW               */

/*******************************************/
void zoom9_draw() {
    for (unsigned i = 0; i < mapInfo.features_by_area.size(); i++) {
        draw_features(mapInfo.features_by_area[i].index, mapInfo.features_by_area[i].colour, mapInfo.features_by_area[i].closed);
    }
    for (unsigned i = 0; i < mapInfo.open_features.size(); i++) {
        draw_features(mapInfo.open_features[i].index, mapInfo.open_features[i].colour, mapInfo.open_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++)
        draw_street_segment(mapInfo.major_roads[j], WHITE, 10);
    for (unsigned j = 0; j < mapInfo.highways.size(); j++)
        draw_street_segment(mapInfo.highways[j], ORANGE, 10);

    for (unsigned i = 0; i < mapInfo.minor_roads.size(); i++) {
        draw_street_segment(mapInfo.minor_roads[i], WHITE, 7);
    }
    for (unsigned i = 0; i < mapInfo.buildings.size(); i++) {
        bool closed = is_closed(i);
        draw_features(mapInfo.buildings[i], t_color(222, 198, 182), closed);
    }
    for (unsigned i = 0; i < mapInfo.subway_stations.size(); i++) {
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/transit.png", mapInfo.subway_stations[i]);
    }
    draw_poi(1);
    for (unsigned i = 0; i < mapInfo.zero_area_features.size(); i++) {
        draw_features(mapInfo.zero_area_features[i].index, mapInfo.zero_area_features[i].colour, mapInfo.zero_area_features[i].closed);
    }
    for (unsigned j = 0; j < mapInfo.major_roads.size(); j++) {
        draw_street_name(mapInfo.major_roads[j], 9);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.major_roads[j]);
    }
    for (unsigned j = 0; j < mapInfo.highways.size(); j++) {
        draw_street_name(mapInfo.highways[j], 9);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.highways[j]);
    }
    for (unsigned j = 0; j < mapInfo.minor_roads.size(); j++) {
        draw_street_name(mapInfo.minor_roads[j], 8);
        if (j % 2 == 0)
            draw_segment_direction(mapInfo.minor_roads[j]);
    }

}

/*******************************************/
/*                ZOOM10 DRAW               */

/*******************************************/
void zoom10_draw() {
    zoom9_draw();
}

/*******************************************/
/*          HIGHLIGHT FEATURE              */

/*******************************************/
void highlight_feature(unsigned featureIndex) {
    bool closed = is_closed(featureIndex);
    if (closed) {
        draw_features(featureIndex, t_color(255, 0, 0, 255 / 3), closed);
        draw_features(featureIndex, t_color(255, 0, 0), false);
    } else {
        draw_features(featureIndex, t_color(255, 0, 0), false);
    }
}

// draws the street in semi-transparent red

void highlight_street(unsigned streetIndex) {
    std::vector<unsigned> segsToHighlight;
    segsToHighlight = find_street_street_segments(streetIndex);

    for (unsigned i = 0; i < segsToHighlight.size(); i++) {
        draw_street_segment(segsToHighlight[i], t_color(255, 0, 0, 255 / 3), 7);
    }
}

/*******************************************/
/*        HIGHLIGHT INTERSECTION           */

/*******************************************/
void highlight_intersection(unsigned intersectionIndex) {
    t_point position = getXY(mapInfo.intersection_position[intersectionIndex]);

    setcolor(t_color(255, 0, 0, 255 / 3));
    fillarc(position.x, position.y, 0.000005, 0, 360);
    setlinewidth(2);
    setcolor(t_color(255, 0, 0));
    drawarc(position.x, position.y, 0.000005, 0, 360);

}

/*******************************************/
/*            HIGHLIGHT POI                */

/*******************************************/
void highlight_POI(unsigned POIindex) {
    t_point position = getXY(mapInfo.poi_position[POIindex]);

    //    setcolor(t_color(255, 0, 0));
    //    fillarc(position.x, position.y, 0.000005, 0, 360);

    setcolor(t_color(255, 0, 0));

    drawarc(position.x, position.y, 0.000005, 0, 360);

}

/*******************************************/
/*         ACT ON MOUSEBUTTON              */

/*******************************************/
void act_on_mousebutton(float x, float y, t_event_buttonPressed button_info) {
    LatLon point = getLatLon(x, y);
    std::vector<std::string> streetNames;
    //t_point position(x,y);

    unsigned poi, intersection;

    draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/pin.png", point);

    // update the information panel with the information on the closest points to where the user clicked
    poi = find_closest_point_of_interest(point);
    intersection = find_closest_intersection(point);
    streetNames = find_intersection_street_names(intersection);
    clear_popup();
    update_message_popup("Information Panel");
    update_message_popup("");
    update_message_popup("Point of Interest:");
    update_message_popup(getPointOfInterestName(poi));
    update_message_popup("Type: " + getPointOfInterestType(poi));

    update_message_popup("Closest Intersection:");

    for (unsigned i = 0; i < streetNames.size(); i++) {
        //        std::sort(streetNames[i].begin(), streetNames[i].end());
        //        streetNames[i].erase(std::unique(streetNames[i].begin(), streetNames[i].end()), streetNames[i].end());
        if (streetNames[i] != "<unknown>") {
            update_message_popup(streetNames[i]);
        }

    }




}
/*******************************************/
/*           DRAW POI NAME                 */

/*******************************************/
void show_poi_names(void (*drawscreen_ptr) (void)) {
    if (!mapInfo.poi_name_drawn) {
        mapInfo.poi_name_drawn = true;
    } else {
        mapInfo.poi_name_drawn = false;
    }
    drawscreen();
}

void more_poi_display(void (*drawscreen_ptr) (void)) {
    char old_button_name[200], new_button_name[200];


    if (!mapInfo.more_pois) {
        sprintf(old_button_name, "More POIs");
        sprintf(new_button_name, "Less POIs");
        change_button_text(old_button_name, new_button_name);
        
        mapInfo.more_pois = true;
    } else {
        sprintf(old_button_name, "Less POIs");
        sprintf(new_button_name, "More POIs");
        change_button_text(old_button_name, new_button_name);
        
        mapInfo.more_pois = false;
    }
    drawscreen();
}
/*******************************************/
/*           DRAW POI NAME                 */

/*******************************************/
void draw_poi_name(unsigned poi) {
    if (!mapInfo.poi_name_drawn)
        return;
    t_point position = getXY(mapInfo.poi_position[poi]);
    string name = getPointOfInterestName(poi);
    setcolor(BLACK);
    position.y += 0.000006 / zoom_level;
    setfontsize(7);
    settextrotation(0);
    drawtext(position, name, 1000, 1000);
}

/*******************************************/
/*              DRAW POI                   */

/*******************************************/
void draw_poi(int amount) {
    for (unsigned i = 0; i < mapInfo.poi_type.size(); i += amount) {
        int type = mapInfo.poi_type[i];
        t_point position = getXY(mapInfo.poi_position[i]);


        switch (type) {
            case 1:
                if (zoom_level > 6) draw_poi_name(i);
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/school.png", mapInfo.poi_position[i]);
                break;
            case 2:
                if (zoom_level > 6) draw_poi_name(i);
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/bank.png", mapInfo.poi_position[i]);
                break;
            case 3:
                if (zoom_level > 6) draw_poi_name(i);
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/restaurant.png", mapInfo.poi_position[i]);
                break;
            case 4:
                if (zoom_level > 6) draw_poi_name(i);
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/cafe.png", mapInfo.poi_position[i]);
                break;
            case 5:
                if (zoom_level > 6) draw_poi_name(i);
                //std::cout << "hospital"<<std::endl;
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/hospital.png", mapInfo.poi_position[i]);
                break;
            case 6:
                if (zoom_level > 6) draw_poi_name(i);
                //std::cout << "hotel"<<std::endl;
                draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/hotel.png", mapInfo.poi_position[i]);
                break;
            case 7:
                if (mapInfo.more_pois) {
                    setcolor(153, 0, 153);
                    if (zoom_level > 8) draw_poi_name(i);
                    fillarc(position.x, position.y, 0.0000005, 0, 360);
                }
                break;
            default:
                break;


        }

    }
}

/*******************************************/
/*              DRAW SCHOOLS               */

/*******************************************/
void draw_schools(float amount) {
    for (unsigned i = 0; i < (mapInfo.schools.size()) * amount; i++) {
        unsigned id = mapInfo.schools[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/school.png", mapInfo.poi_position[id]);
    }
}

void draw_banks(float amount) {
    for (unsigned i = 0; i < (mapInfo.banks.size()) * amount; i++) {
        unsigned id = mapInfo.banks[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/bank.png", mapInfo.poi_position[id]);
    }
}

void draw_cafes(float amount) {
    for (unsigned i = 0; i < (mapInfo.cafes.size()) * amount; i++) {
        unsigned id = mapInfo.cafes[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/cafe.png", mapInfo.poi_position[id]);
    }
}

/*******************************************/
/*             DRAW HOTELS                 */

/*******************************************/
void draw_hotels(float amount) {
    for (unsigned i = 0; i < (mapInfo.hotels.size()) * amount; i++) {
        unsigned id = mapInfo.hotels[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/hotel.png", mapInfo.poi_position[id]);
    }
}

/*******************************************/
/*            DRAW RESTAURANTS             */

/*******************************************/
void draw_restaurants(float amount) {
    for (unsigned i = 0; i < (mapInfo.restaurants.size()) * amount; i++) {
        unsigned id = mapInfo.restaurants[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/restaurant.png", mapInfo.poi_position[id]);
    }
}

/*******************************************/
/*            DRAW HOSPITALS               */

/*******************************************/
void draw_hospitals(float amount) {
    for (unsigned i = 0; i < (mapInfo.hospitals.size()) * amount; i++) {
        unsigned id = mapInfo.hospitals[i];
        draw_icons("/nfs/ug/homes-5/r/roscoeol/mapper_repo/mapper/libstreetmap/src/icons/hospital.png", mapInfo.poi_position[id]);
    }
}

/*******************************************/
/*             DRAW OTHER                  */

/*******************************************/
void draw_other(float amount) {
    for (unsigned i = 0; i < (mapInfo.other.size()) * amount; i++) {
        int type = mapInfo.poi_type[i];
        t_point position = getXY(mapInfo.poi_position[i]);
        setcolor(153, 0, 153);

        fillarc(position.x, position.y, 0.0000005, 0, 360);
    }
}


